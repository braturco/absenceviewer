<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Employee Headcount Report</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            padding: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: 600;
            color: #555;
            font-size: 14px;
        }

        input[type="file"],
        input[type="date"] {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input[type="file"]:hover,
        input[type="date"]:hover {
            border-color: #667eea;
        }

        button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }

        button:hover {
            background: #5568d3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .info-panel {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
            display: none;
        }

        .info-panel.show {
            display: block;
        }

        .info-panel h3 {
            color: #333;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .info-panel p {
            color: #666;
            font-size: 14px;
            margin: 5px 0;
        }

        .table-container {
            overflow-x: auto;
            margin-top: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            font-size: 13px;
        }

        th {
            background: #667eea;
            color: white;
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        td {
            padding: 10px 8px;
            border-bottom: 1px solid #eee;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .total-row {
            background: #f0f0f0;
            font-weight: 600;
        }

        .total-row:hover {
            background: #e8e8e8;
        }

        .number {
            text-align: right;
        }

        .positive {
            color: #28a745;
        }

        .negative {
            color: #dc3545;
        }

        .error {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            border-radius: 5px;
            color: #721c24;
            margin-top: 20px;
        }

        .export-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #eee;
        }

        .nav-bar {
            background: #f8f9fa;
            padding: 12px 15px;
            margin: -30px -30px 20px -30px;
            border-radius: 10px 10px 0 0;
            border-bottom: 2px solid #e0e0e0;
        }

        .nav-bar a {
            margin: 0 10px;
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
        }

        .nav-bar a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="nav-bar">
            <strong>Tools:</strong>
            <a href="index.html">Absence Viewer</a> |
            <a href="employee-headcount-report.html">Employee Headcount Report</a>
        </div>

        <h1>Employee Headcount Report</h1>
        <p class="subtitle">CA-BL002-Earth & Environment</p>

        <div class="controls">
            <div class="control-group">
                <label for="fileInput">Upload Employee Data (XLSX):</label>
                <input type="file" id="fileInput" accept=".xlsx, .xls">
            </div>
            <div class="control-group">
                <label for="absenceFileInput">Upload Absence Data (XLSX):</label>
                <input type="file" id="absenceFileInput" accept=".xlsx, .xls">
            </div>
            <div class="control-group">
                <label for="reportDate">Reporting Date:</label>
                <input type="date" id="reportDate">
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="generateBtn" disabled>Generate Report</button>
            </div>
        </div>

        <div id="infoPanel" class="info-panel">
            <h3>Report Information</h3>
            <p id="reportPeriod"></p>
            <p id="recordCount"></p>
        </div>

        <div id="errorMessage" class="error" style="display: none;"></div>

        <div class="table-container">
            <table id="reportTable" style="display: none;">
                <thead>
                    <tr>
                        <th>Market Sub Sector</th>
                        <th class="number">Prior Month Total</th>
                        <th class="number">Period Starters</th>
                        <th class="number">Period Leavers</th>
                        <th class="number">Forecast End of Period</th>
                        <th class="number">Variance</th>
                        <th class="number">TLOs</th>
                        <th class="number">EEs on Leave</th>
                    </tr>
                </thead>
                <tbody id="reportBody">
                </tbody>
            </table>
        </div>

        <div class="export-section" id="exportSection" style="display: none;">
            <button id="exportBtn">Export to Excel</button>
        </div>
    </div>

    <script>
        let staffListData = [];
        let staffExitData = [];
        let absenceData = [];
        let reportData = [];
        let filesLoaded = { employee: false, absence: false };

        const fileInput = document.getElementById('fileInput');
        const absenceFileInput = document.getElementById('absenceFileInput');
        const reportDate = document.getElementById('reportDate');
        const generateBtn = document.getElementById('generateBtn');
        const exportBtn = document.getElementById('exportBtn');
        const infoPanel = document.getElementById('infoPanel');
        const errorMessage = document.getElementById('errorMessage');
        const reportTable = document.getElementById('reportTable');
        const reportBody = document.getElementById('reportBody');
        const exportSection = document.getElementById('exportSection');

        // Set default date to today
        reportDate.valueAsDate = new Date();

        fileInput.addEventListener('change', handleFileUpload);
        absenceFileInput.addEventListener('change', handleAbsenceFileUpload);
        generateBtn.addEventListener('click', generateReport);
        exportBtn.addEventListener('click', exportToExcel);

        function checkFilesLoaded() {
            generateBtn.disabled = !(filesLoaded.employee && filesLoaded.absence);
        }

        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array', cellDates: true });

                    // Check if workbook has sheets
                    if (!workbook.SheetNames || workbook.SheetNames.length === 0) {
                        showError('No sheets found in the workbook. The file may be encrypted or corrupted.');
                        return;
                    }

                    console.log('Available sheets:', workbook.SheetNames);

                    // Find Staff List tab (flexible matching)
                    let staffListSheetName = workbook.SheetNames.find(name =>
                        name.includes('Staff_List') || name.includes('Staff List') || name.includes('80-1')
                    );

                    // Default to Sheet1 if specific name not found
                    if (!staffListSheetName) {
                        staffListSheetName = workbook.SheetNames[0]; // Default to first sheet
                        console.log('Using first sheet for Staff List:', staffListSheetName);
                    }

                    const staffListSheet = workbook.Sheets[staffListSheetName];
                    if (!staffListSheet) {
                        showError('Could not read staff list sheet. Available sheets: ' + workbook.SheetNames.join(', '));
                        return;
                    }
                    staffListData = XLSX.utils.sheet_to_json(staffListSheet, { raw: false, dateNF: 'yyyy-mm-dd' });

                    // Find Staff Exit tab (flexible matching)
                    let staffExitSheetName = workbook.SheetNames.find(name =>
                        name.includes('Staff_Exit') || name.includes('Staff Exit') || name.includes('80-2') || name.includes('Exit')
                    );

                    // Default to Sheet3 if specific name not found
                    if (!staffExitSheetName && workbook.SheetNames.length >= 3) {
                        staffExitSheetName = workbook.SheetNames[2]; // Default to third sheet
                        console.log('Using third sheet for Staff Exit:', staffExitSheetName);
                    } else if (!staffExitSheetName) {
                        showError('Could not find Staff Exit sheet. Need at least 3 sheets. Available: ' + workbook.SheetNames.join(', '));
                        return;
                    }

                    const staffExitSheet = workbook.Sheets[staffExitSheetName];
                    if (!staffExitSheet) {
                        showError('Could not read staff exit sheet. Available sheets: ' + workbook.SheetNames.join(', '));
                        return;
                    }
                    staffExitData = XLSX.utils.sheet_to_json(staffExitSheet, { raw: false, dateNF: 'yyyy-mm-dd' });

                    filesLoaded.employee = true;
                    checkFilesLoaded();
                    hideError();
                    console.log('Employee data loaded from sheets:', staffListSheetName, 'and', staffExitSheetName);
                    console.log('Records:', staffListData.length, 'active,', staffExitData.length, 'exits');
                } catch (error) {
                    if (error.message.includes('Unsupported file') || error.message.includes('CFB')) {
                        showError('Error: File appears to be encrypted or password-protected. Please save as a new unencrypted XLSX file.');
                    } else {
                        showError('Error reading employee file: ' + error.message);
                    }
                    filesLoaded.employee = false;
                    checkFilesLoaded();
                    console.error(error);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function handleAbsenceFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array', cellDates: true });

                    // Check if workbook has sheets
                    if (!workbook.SheetNames || workbook.SheetNames.length === 0) {
                        showError('No sheets found in the absence file. The file may be encrypted or corrupted.');
                        return;
                    }

                    console.log('Available sheets in absence file:', workbook.SheetNames);

                    // Get first sheet (assuming absence data is in first sheet)
                    const firstSheetName = workbook.SheetNames[0];
                    const absenceSheet = workbook.Sheets[firstSheetName];
                    if (!absenceSheet) {
                        showError('No sheets found in absence file');
                        return;
                    }
                    absenceData = XLSX.utils.sheet_to_json(absenceSheet, { raw: false, dateNF: 'yyyy-mm-dd' });

                    filesLoaded.absence = true;
                    checkFilesLoaded();
                    hideError();
                    console.log('Absence data loaded from sheet:', firstSheetName);
                    console.log('Records:', absenceData.length);
                } catch (error) {
                    if (error.message.includes('Unsupported file') || error.message.includes('CFB')) {
                        showError('Error: Absence file appears to be encrypted or password-protected. Please save as a new unencrypted XLSX file.');
                    } else {
                        showError('Error reading absence file: ' + error.message);
                    }
                    filesLoaded.absence = false;
                    checkFilesLoaded();
                    console.error(error);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function parseDate(dateStr) {
            if (!dateStr) return null;

            // Handle different date formats
            if (dateStr instanceof Date) return dateStr;

            // Try parsing as ISO date
            let date = new Date(dateStr);
            if (!isNaN(date.getTime())) return date;

            // Try MM/DD/YYYY format
            const parts = dateStr.split('/');
            if (parts.length === 3) {
                date = new Date(parts[2], parts[0] - 1, parts[1]);
                if (!isNaN(date.getTime())) return date;
            }

            return null;
        }

        function getMonthRange(date) {
            const year = date.getFullYear();
            const month = date.getMonth();
            const start = new Date(year, month, 1);
            const end = new Date(year, month + 1, 0);
            return { start, end };
        }

        function getPriorMonthRange(date) {
            const year = date.getFullYear();
            const month = date.getMonth();
            const start = new Date(year, month - 1, 1);
            const end = new Date(year, month, 0);
            return { start, end };
        }

        function isInMonth(dateStr, monthStart, monthEnd) {
            const date = parseDate(dateStr);
            if (!date) return false;
            return date >= monthStart && date <= monthEnd;
        }

        function isBeforeOrInMonth(dateStr, monthEnd) {
            const date = parseDate(dateStr);
            if (!date) return false;
            return date <= monthEnd;
        }

        function generateReport() {
            try {
                const selectedDate = new Date(reportDate.value);
                const currentMonth = getMonthRange(selectedDate);
                const priorMonth = getPriorMonthRange(selectedDate);

                // Get period name (P01, P02, etc.)
                const periodNum = selectedDate.getMonth() + 1;
                const periodName = 'P' + String(periodNum).padStart(2, '0');
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                                   'July', 'August', 'September', 'October', 'November', 'December'];

                // Filter data by Market Sector and User Person Type
                // Use flexible matching to handle special characters
                const targetSectorMatch = (sector) => {
                    if (!sector) return false;
                    return sector.includes('CA-BL002') && sector.includes('Earth');
                };

                // Debug: Show unique market sectors
                const uniqueSectors = new Set(staffListData.map(emp => emp['Market Sector']));
                console.log('Unique Market Sectors found:', Array.from(uniqueSectors));
                console.log('Filtering for sectors containing: CA-BL002 and Earth');

                const filteredStaffList = staffListData.filter(emp =>
                    targetSectorMatch(emp['Market Sector']) &&
                    emp['User Person Type'] !== 'ICRC'
                );

                const filteredStaffExit = staffExitData.filter(emp =>
                    targetSectorMatch(emp['Market Sector']) &&
                    emp['User Person Type'] !== 'ICRC'
                );

                console.log('Filtered counts:', filteredStaffList.length, 'staff,', filteredStaffExit.length, 'exits');

                if (filteredStaffList.length === 0 && filteredStaffExit.length === 0) {
                    showError('No employees found with Market Sector "' + targetSector + '". Available sectors: ' + Array.from(uniqueSectors).join(', '));
                    return;
                }

                // Group by Market Sub Sector
                const subSectors = new Set();
                filteredStaffList.forEach(emp => {
                    if (emp['Market Sub Sector']) {
                        subSectors.add(emp['Market Sub Sector']);
                    }
                });
                filteredStaffExit.forEach(emp => {
                    if (emp['Market Sub Sector']) {
                        subSectors.add(emp['Market Sub Sector']);
                    }
                });

                reportData = [];
                let totals = {
                    priorMonthTotal: 0,
                    starters: 0,
                    leavers: 0,
                    forecast: 0,
                    variance: 0,
                    tlos: 0,
                    onLeave: 0
                };

                Array.from(subSectors).sort().forEach(subSector => {
                    const subSectorStaffList = filteredStaffList.filter(emp => emp['Market Sub Sector'] === subSector);
                    const subSectorStaffExit = filteredStaffExit.filter(emp => emp['Market Sub Sector'] === subSector);

                    // Prior Month Total: Active employees as of end of prior month
                    const priorMonthTotal = subSectorStaffList.filter(emp => {
                        const statusType = emp['Employee Status Type'] || '';
                        const hireDate = parseDate(emp['Date of Hire/Rehire']);
                        return statusType.startsWith('Active') &&
                               hireDate &&
                               hireDate <= priorMonth.end;
                    }).length;

                    // Period Starters: Hired in current month
                    const starters = subSectorStaffList.filter(emp =>
                        isInMonth(emp['Date of Hire/Rehire'], currentMonth.start, currentMonth.end)
                    ).length;

                    // Period Leavers: Left in current month
                    const leavers = subSectorStaffExit.filter(emp =>
                        isInMonth(emp['Last Day of Employment'], currentMonth.start, currentMonth.end)
                    ).length;

                    // EEs on Leave
                    const onLeave = subSectorStaffList.filter(emp => {
                        const statusType = emp['Employee Status Type'] || '';
                        return statusType === 'Leave';
                    }).length;

                    // Forecast: Active + Pending Working (with future hire date)
                    const activeCount = subSectorStaffList.filter(emp => {
                        const statusType = emp['Employee Status Type'] || '';
                        const hireDate = parseDate(emp['Date of Hire/Rehire']);
                        return statusType.startsWith('Active') &&
                               hireDate &&
                               hireDate <= currentMonth.end;
                    }).length;

                    const pendingCount = subSectorStaffList.filter(emp => {
                        const statusType = emp['Employee Status Type'] || '';
                        const hireDate = parseDate(emp['Date of Hire/Rehire']);
                        return statusType === 'Pending Working' &&
                               hireDate &&
                               hireDate <= currentMonth.end;
                    }).length;

                    const forecast = activeCount + pendingCount;

                    // Variance: Forecast - Prior Month
                    const variance = forecast - priorMonthTotal;

                    // TLOs: Count employees on furlough (temporary layoff)
                    // Match Person Number from absence file to Employee ID from staff list
                    const furloughPersonNumbers = new Set(
                        absenceData
                            .filter(absence => {
                                const status = absence['Assignment Status'] || '';
                                return status.startsWith('Furlough');
                            })
                            .map(absence => absence['Person Number'])
                    );

                    const tlos = subSectorStaffList.filter(emp => {
                        const employeeId = emp['Employee ID'];
                        return furloughPersonNumbers.has(employeeId);
                    }).length;

                    reportData.push({
                        subSector,
                        priorMonthTotal,
                        starters,
                        leavers,
                        forecast,
                        variance,
                        tlos,
                        onLeave
                    });

                    totals.priorMonthTotal += priorMonthTotal;
                    totals.starters += starters;
                    totals.leavers += leavers;
                    totals.forecast += forecast;
                    totals.variance += variance;
                    totals.tlos += tlos;
                    totals.onLeave += onLeave;
                });

                // Display results
                displayReport(totals, periodName, monthNames[selectedDate.getMonth()], selectedDate.getFullYear());

                // Show info panel
                document.getElementById('reportPeriod').textContent =
                    `Report Period: ${periodName} (${monthNames[selectedDate.getMonth()]} ${selectedDate.getFullYear()})`;
                document.getElementById('recordCount').textContent =
                    `Records Processed: ${filteredStaffList.length} active, ${filteredStaffExit.length} exits, ${absenceData.length} absence records`;
                infoPanel.classList.add('show');

            } catch (error) {
                showError('Error generating report: ' + error.message);
                console.error(error);
            }
        }

        function displayReport(totals, periodName, monthName, year) {
            reportBody.innerHTML = '';

            reportData.forEach(row => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${row.subSector}</td>
                    <td class="number">${row.priorMonthTotal}</td>
                    <td class="number">${row.starters}</td>
                    <td class="number">${row.leavers}</td>
                    <td class="number">${row.forecast}</td>
                    <td class="number ${row.variance >= 0 ? 'positive' : 'negative'}">${row.variance >= 0 ? '+' : ''}${row.variance}</td>
                    <td class="number">${row.tlos}</td>
                    <td class="number">${row.onLeave}</td>
                `;
                reportBody.appendChild(tr);
            });

            // Add totals row
            const totalRow = document.createElement('tr');
            totalRow.className = 'total-row';
            totalRow.innerHTML = `
                <td><strong>TOTAL</strong></td>
                <td class="number"><strong>${totals.priorMonthTotal}</strong></td>
                <td class="number"><strong>${totals.starters}</strong></td>
                <td class="number"><strong>${totals.leavers}</strong></td>
                <td class="number"><strong>${totals.forecast}</strong></td>
                <td class="number ${totals.variance >= 0 ? 'positive' : 'negative'}"><strong>${totals.variance >= 0 ? '+' : ''}${totals.variance}</strong></td>
                <td class="number"><strong>${totals.tlos}</strong></td>
                <td class="number"><strong>${totals.onLeave}</strong></td>
            `;
            reportBody.appendChild(totalRow);

            reportTable.style.display = 'table';
            exportSection.style.display = 'block';
        }

        function exportToExcel() {
            const selectedDate = new Date(reportDate.value);
            const periodNum = selectedDate.getMonth() + 1;
            const periodName = 'P' + String(periodNum).padStart(2, '0');
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                               'July', 'August', 'September', 'October', 'November', 'December'];

            // Prepare data for export
            const exportData = [];

            // Add header
            exportData.push([
                'Market Sub Sector',
                'Prior Month Total',
                'Period Starters',
                'Period Leavers',
                'Forecast End of Period',
                'Variance',
                'TLOs',
                'EEs on Leave'
            ]);

            // Add data rows
            reportData.forEach(row => {
                exportData.push([
                    row.subSector,
                    row.priorMonthTotal,
                    row.starters,
                    row.leavers,
                    row.forecast,
                    row.variance,
                    row.tlos,
                    row.onLeave
                ]);
            });

            // Add totals row
            const totals = reportData.reduce((acc, row) => ({
                priorMonthTotal: acc.priorMonthTotal + row.priorMonthTotal,
                starters: acc.starters + row.starters,
                leavers: acc.leavers + row.leavers,
                forecast: acc.forecast + row.forecast,
                variance: acc.variance + row.variance,
                tlos: acc.tlos + row.tlos,
                onLeave: acc.onLeave + row.onLeave
            }), { priorMonthTotal: 0, starters: 0, leavers: 0, forecast: 0, variance: 0, tlos: 0, onLeave: 0 });

            exportData.push([
                'TOTAL',
                totals.priorMonthTotal,
                totals.starters,
                totals.leavers,
                totals.forecast,
                totals.variance,
                totals.tlos,
                totals.onLeave
            ]);

            // Create workbook and worksheet
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(exportData);

            // Add worksheet to workbook
            XLSX.utils.book_append_sheet(wb, ws, 'Headcount Report');

            // Generate filename
            const filename = `Headcount_Report_${periodName}_${monthNames[selectedDate.getMonth()]}_${selectedDate.getFullYear()}.xlsx`;

            // Save file
            XLSX.writeFile(wb, filename);
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }

        function hideError() {
            errorMessage.style.display = 'none';
        }
    </script>
</body>
</html>